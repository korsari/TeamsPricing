using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
<<<<<<< Updated upstream
using MathNet.Numerics.Distributions;
using MathNet.Numerics.Statistics;
=======
>>>>>>> Stashed changes
using FileHelpers;

namespace TeamsPricing
{
    class Program
    {
        static void Main(string[] args)
        {
<<<<<<< Updated upstream
            Tuple<string, string>[] selectionRules = GetRules("D:\\C#\\FootballBets\\Rules.csv");
            Dictionary<string, Dictionary<string, string>> selectionRulesTable = GetRulesTable("D:\\C#\\FootballBets\\RulesTable.csv");
            Dictionary <string, TeamFootball[]> groups = GetGroups("D:\\C#\\FootballBets\\Teams.csv");
            int[] prices = {1000,500,250,250,125,125,125,125,50,50,50,50,50,50,50,50,25,25,25,25,25,25,25,25 };
            Dictionary<string, float> mcFinalPrices = new Dictionary<string, float>();
            int nIterations = 1000000;
            string goaslMethod = "QuickWeighted";

            foreach ( KeyValuePair<string, TeamFootball[]> group in groups)
            {
                foreach (TeamFootball team in group.Value)
                    mcFinalPrices.Add(team.Name, 0);
            }

            Competition euro2016 = new Competition(groups, selectionRules, selectionRulesTable, goaslMethod);
=======
            Tuple<string, string>[] selectionRules = GetRules(@"C:\Git\TeamsPricing\Rules.csv");
            Dictionary<string, Dictionary<string, string>> selectionRulesTable = GetRulesTable(@"C:\Git\TeamsPricing\RulesTable.csv");
            Dictionary<string, TeamFootball[]> groups = GetGroups(@"C:\Git\TeamsPricing\Teams.csv");
            int[] prices = { 1000, 500, 250, 250, 125, 125, 125, 125, 50, 50, 50, 50, 50, 50, 50, 50, 25, 25, 25, 25, 25, 25, 25, 25 };
            Dictionary<string, float> mcFinalPrices = new Dictionary<string, float>();
            int nIterations = 100000;

            foreach (KeyValuePair<string, TeamFootball[]> group in groups)
            {
                foreach (TeamFootball team in group.Value)
                {
                    mcFinalPrices.Add(team.Name, 0);
                }
            }

            Competition euro2016 = new Competition(groups, selectionRules, selectionRulesTable);
>>>>>>> Stashed changes
            TeamFootball[] result;
            for (int iteration = 0; iteration < nIterations; iteration++)
            {
                result = euro2016.PlayCompetition();
                for (int j = 0; j < result.Length; j++)
                {
                    mcFinalPrices[result[j].Name] += prices[j];
<<<<<<< Updated upstream
                }
                if (iteration % (nIterations/10) == 0)
                    Console.WriteLine(iteration/(nIterations/100)+ "%");
                euro2016.Reset();
            }

            foreach (KeyValuePair<string, float> team in mcFinalPrices.ToList())
                mcFinalPrices[team.Key] /= nIterations;

            List<KeyValuePair<string,float>> outputFinal = mcFinalPrices.ToList();
            outputFinal.Sort(
                delegate (KeyValuePair<string, float> team1, KeyValuePair<string, float> team2)
                {
                    return team1.Value.CompareTo(team2.Value);
                });
            outputFinal.Reverse();
            foreach (KeyValuePair<string, float> team in outputFinal)
                Console.WriteLine("{0} = {1}$", team.Key, team.Value);
                //Console.WriteLine(team.Value);
=======
                }
                if (iteration % (nIterations / 10) == 0)
                {
                    Console.WriteLine(iteration / (nIterations / 100) + "%");
                }
                euro2016.Reset();
            }

            //pq tu fais des toList() a tout bout de champs !!! c'est couteu en temps et en memoire
            //List<KeyValuePair<string,float>> outputFinal = mcFinalPrices.ToList();

            // essaye d'utiliser var dans tes foreach.
            // ca t'evite a rechanger tout si tu changes tonn type de collection
            foreach (var team in mcFinalPrices.OrderByDescending(x => x.Value))
            {
                Console.WriteLine("{0} = {1}$", team.Key, team.Value / nIterations);
            }
>>>>>>> Stashed changes
            Console.ReadLine();
        }

        public static Tuple<string, string>[] GetRules(string filePath)
        {
            var engine = new FileHelperEngine<Rules>();
            var records = engine.ReadFile(filePath);
            Tuple<string, string>[] result = new Tuple<string, string>[records.Length];
            for (int i = 0; i < records.Length; i++)
            {
                // ca te fait economiser un acces memoire !
                var record = records[i];
                result[i] = new Tuple<string, string>(record.team1, record.team2);
            }
            return result;
        }

        public static Dictionary<string, TeamFootball[]> GetGroups(string filePath)
        {
            var engine = new FileHelperEngine<Teams>();
            var records = engine.ReadFile(filePath);
            Dictionary<string, List<TeamFootball>> resultList = new Dictionary<string, List<TeamFootball>>();
            foreach (Teams team in records)
            {
                if (!resultList.ContainsKey(team.Group))
                    resultList.Add(team.Group, new List<TeamFootball>());
                resultList[team.Group].Add(new TeamFootball(team.Name, team.Points));
            }
            Dictionary<string, TeamFootball[]> result = new Dictionary<string, TeamFootball[]>();
            foreach (KeyValuePair<string, List<TeamFootball>> res in resultList)
            {
                result.Add(res.Key, res.Value.ToArray());
            }
            return result;
        }

        public static Dictionary<string, Dictionary<string, string>> GetRulesTable(string filePath)
        {
            var engine = new FileHelperEngine<RulesTable>();
            var records = engine.ReadFile(filePath);
            Dictionary<string, Dictionary<string, string>> result = new Dictionary<string, Dictionary<string, string>>();
            foreach (RulesTable rules in records)
            {
                Dictionary<string, string> tmp = new Dictionary<string, string>();
                tmp.Add("1A", rules.Team1);
                tmp.Add("1B", rules.Team2);
                tmp.Add("1C", rules.Team3);
                tmp.Add("1D", rules.Team4);
                result.Add(rules.Key, tmp);
            }
            return result;
        }

        public static void ReworkTeamPoints(Dictionary<string, TeamFootball[]> groups, string method)
        {
            List<float> pointsList = new List<float>();
            foreach (KeyValuePair<string,TeamFootball[]> group in groups)
            {
                foreach(TeamFootball team in group.Value)
                {
                    pointsList.Add(team.Points);
                }
            }
            switch (method)
            {
                case "stupid":
                    Tuple<double,double> meanVar = Statistics.MeanVariance(pointsList);
                    foreach (KeyValuePair<string, TeamFootball[]> group in groups)
                    {
                        foreach (TeamFootball team in group.Value)
                        {
                            team.Points = (team.Points - (float)meanVar.Item1) / (float)meanVar.Item2;
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    }

    [DelimitedRecord(",")]
    // precise toujours ce qu'est ta classe
    // Et faudrait mieux que tu bosses avec des Ids (short)
    // plus robuste aux changement, aux ameliorations et moins lourd en mémoire !
    public class Rules
    {
        // property => Maj
        public string Team1;
        public string Team2;
    }

    [DelimitedRecord(",")]
    public class RulesTable
    {
        public string Key;
        public string Team1;
        public string Team2;
        public string Team3;
        public string Team4;
    }

    [DelimitedRecord(",")]
    public class Teams
    {
        public string Group;
        public string Name;
        public float Points;
    }

}
